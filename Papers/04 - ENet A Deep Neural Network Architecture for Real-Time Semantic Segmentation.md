#paper

# Abstract
The ability to perform pixel-wise semantic segmentation in real-time is of paramount importance in mobile applications. Recent deep neural networks aimed at this task have the disadvantage of **requiring a large number of floating point operations** and have long run-times that hinder their usability. In this paper, we propose a **novel deep neural network architecture** named ENet (efficient neural network), created specifically for **tasks requiring low latency operation**. ENet is up to 18×faster, requires 75× less FLOPs, has 79× less parameters, and provides <u>similar or better accuracy to existing models</u>. We have tested it on CamVid, Cityscapes and SUN datasets and report on comparisons with existing state-of-the-art methods, and the trade-offs between accuracy and processing time of a network. We present performance measurements of the proposed architecture on embedded systems and suggest possible software improvements that could make ENet even faster.

---

# Introduction
Recent interest in augmented reality wearables, home-automation devices, and self-driving vehicles has created a strong need for semantic-segmentation (or visual scene understanding) algorithms that can operate in real-time on low-power mobile devices. These algorithms label each and every pixel in the image with one of the object classes. In recent years, the availability of larger datasets and computationally-powerful machines have helped deep convolutional neural networks (CNNs) surpass the performance of many conventional computer vision algorithms. Even though CNNs are increasingly successful at classification and categorization tasks, they provide <u>coarse spatial results when applied to pixel-wise labeling of images</u>. Therefore, they are often <u>cascaded with other algorithms to refine the results</u>, such as color based segmentation or conditional random fields, to name a few. In order to both spatially classify and finely segment images, several neural network architectures have been proposed, such as [[SegNet]] or fully convolutional networks. All these works are based on a [[VGG16]] architecture, which is a <u>very large model designed for multi-class classification</u>. These references propose networks with <u>huge numbers of parameters, and long inference times</u>. In these conditions, they become unusable for many mobile or battery-powered applications, which require processing images at rates higher than 10 fps. In this paper, we propose a **new neural network architecture** optimized for **fast inference and high accuracy**. In our work, we chose <u>not to use any post-processing steps</u>, which can of course be combined with our method, but would worsen the performance of an end-to-end CNN approach. In Section 3 we propose a fast and **compact encoder-decoder architecture** named ENet. It has been designed according to rules and ideas that have appeared in the literature recently, all of which we discuss in Section 4. Proposed network has been evaluated on Cityscapes and CamVid for driving scenario, whereas SUN dataset has been used for testing our network in an indoor situation. We benchmark it on NVIDIA Jetson TX1 Embedded Systems Module as well as on an NVIDIA Titan X GPU. The results can be found in Section 5.

# Architecture
![[Pasted image 20230429231702.png]]
The architecture of our network is presented in Table 1. It is divided into several stages, as highlighted by horizontal lines in the table and the first digit after each block name. Output sizes are reported for an example input image resolution of 512 × 512. We adopt a view of ResNets that describes them as having a single main branch and extensions with convolutional filters that separate from it, and then merge back with an element-wise addition, as shown in Figure 2b. Each block consists of three convolutional layers: a 1 × 1 projection that reduces the dimensionality, a main convolutional layer (conv in Figure 2b), and a 1 × 1 expansion. We place Batch Normalization and PReLU between all convolutions. Just as in the original paper, we refer to these as bottleneck modules. If the bottleneck is downsampling, a max pooling layer is added to the main branch. Also, the first 1 × 1 projection is replaced with a 2 × 2 convolution with stride 2 in both dimensions. We zero pad the activations, to match the number of feature maps. conv is either a regular, dilated or full convolution (also known as deconvolution or fractionally strided convolution) with 3 × 3 filters. Sometimes we replace it initial with asymmetric convolution i.e. a sequence of 5 × 1 and 1 × 5 convolutions. For the regularizer, we use Spatial Dropout, with p = 0.01 before bottleneck2.0, and p = 0.1 afterwards. 
The initial stage contains a single block, that is presented in Figure 2a. Stage 1 consists of 5 bottleneck blocks, while stage 2 and 3 have the same structure, with the exception that stage 3 does not downsample the input at the beginning (we omit the 0th bottleneck). These three first stages are the encoder. Stage 4 and 5 belong to the decoder.

We did not use bias terms in any of the projections, in order to reduce the number of kernel calls and overall memory operations, as cuDNN uses separate kernels for convolution and bias addition. This choice didn't have any impact on the accuracy. Between each convolutional layer and following non-linearity we use Batch Normalization. In the decoder max pooling is replaced with max unpooling, and padding is replaced with spatial convolution without bias. We did not use pooling indices in the last upsampling module, because the initial block operated on the 3 channels of the input frame, while the final output has C feature maps (the number of object classes). Also, for performance reasons, we decided to place only a bare full convolution as the last module of the network, which alone takes up a sizeable portion of the decoder processing time.

## Design choices
In this section we will discuss our most important experimental results and intuitions, that have shaped the final architecture of ENet. Feature map resolution Downsampling images during semantic segmentation has two main drawbacks. Firstly, reducing feature map resolution implies loss of spatial information like exact edge shape. Secondly, full pixel segmentation requires that the output has the same resolution as the input. This implies that strong downsampling will require equally strong upsampling, which increases model size and computational cost. The first issue has been addressed in FCN by adding the feature maps produced by encoder, and in [[SegNet]] by saving indices of elements chosen in max pooling layers, and using them to produce sparse upsampled maps in the decoder. We followed the SegNet approach, because it allows to reduce memory requirements. Still, we have found that strong downsampling hurts the accuracy, and tried to limit it as much as possible. However, downsampling has one big advantage. Filters operating on downsampled images have a bigger receptive field, that allows them to gather more context. This is especially important when trying to differentiate between classes like, for example, rider and pedestrian in a road scene. It is not enough that the network learns how people look, the context in which they appear is equally important. In the end, we have found that it is better to use dilated convolutions for this purpose. 

### Early downsampling 
One crucial intuition to achieving good performance and real-time operation is realizing that processing large input frames is very expensive. This might sound very obvious, however many popular architectures do not to pay much attention to optimization of early stages of the network, which are often the most expensive by far. ENet first two blocks heavily reduce the input size, and use only a small set of feature maps. The idea behind it, is that visual information is highly spatially redundant, and thus can be compressed into a more efficient representation. Also, our intuition is that the initial network layers should not directly contribute to classification. Instead, they should rather act as good feature extractors and only preprocess the input for later portions of the network. This insight worked well in our experiments; increasing the number of feature maps from 16 to 32 did not improve accuracy on Cityscapes dataset. 

### Decoder size 
In this work we would like to provide a different view on encoder-decoder architectures than the one presented in 11. SegNet is a very symmetric architecture, as the encoder is an exact mirror of the encoder. Instead, our architecture consists of a large encoder, and a small decoder. This is motivated by the idea that the encoder should be able to work in a similar fashion to original classification architectures, i.e. to operate on smaller resolution data and provide for information processing and filtering. Instead, the role of the the decoder, is to upsample the output of the encoder, only fine-tuning the details.

### Nonlinear operations 
A recent paper 31 reports that it is beneficial to use ReLU and Batch Normalization layers before convolutions. We tried applying these ideas to ENet, but this had a detrimental effect on accuracy. Instead, we have found that removing most ReLUs in the initial layers of the network improved the results. It was quite a surprising finding so we decided to investigate its cause. 
We replaced all ReLUs in the network with PReLUs, which use an additional parameter per feature map, with the goal of learning the negative slope of non-linearities. We expected that in layers where identity is a preferable transfer function, PReLU weights will have values close to 1, and conversely, values around 0 if ReLU is preferable. Results of this experiment can be seen in Figure 3. 
Initial layers weights exhibit a large variance and are slightly biased towards positive values, while in the later portions of the encoder they settle to a recurring pattern. All layers in the main branch behave nearly exactly like regular ReLUs, while the weights inside bottleneck modules are negative i.e. the function inverts and scales down negative values. We hypothesize that identity did not work well in our architecture because of its limited depth. The reason why such lossy functions are learned might be that that the original ResNets are networks that can be hundreds of layers deep, while our network uses only a couple of layers, and it needs to quickly filter out information. It is notable that the decoder weights become much more positive and learn functions closer to identity. This
confirms our intuitions that the decoder is used only to fine-tune the upsampled output.

### Information-preserving dimensionality changes 
As stated earlier, it is necessary to downsample the input early, but aggressive dimensionality reduction can also hinder the information flow. A very good approach to this problem has been presented in 28. It has been argued that a method used by the VGG architectures, i.e. as performing a pooling followed by a convolution expanding the dimensionality, however relatively cheap, introduces a representational bottleneck (or forces one to use a greater number of filters, which lowers computational efficiency). On the other hand, pooling after a convolution, that increases feature map depth, is computationally expensive. Therefore, as proposed in 28, we chose to perform pooling operation in parallel with a convolution of stride 2, and concatenate resulting feature maps. This technique allowed us to speed up inference time of the initial block 10 times. Additionally, we have found one problem in the original ResNet architecture. When downsampling, the first 1×1 projection of the convolutional branch is performed with a stride of 2 in both dimensions, which effectively discards 75% of the input. Increasing the filter size to 2 × 2 allows to take the full input into consideration, and thus improves the information flow and accuracy. Of course, it makes these layers 4× more computationally expensive, however there are so few of these in ENet, that the overhead is unnoticeable.

### Factorizing filters 
It has been shown that convolutional weights have a fair amount of redundancy, and each n × n convolution can be decomposed into two smaller ones following each other: one with a n × 1 filter and the other with a 1 × n filter. This idea has been also presented in 28, and from now on we adopt their naming convention and will refer to these as asymmetric convolutions. We have used asymmetric convolutions with n = 5 in our network, so cost of these two operations is similar to a single 3 × 3 convolution. This allowed to increase the variety of functions learned by blocks and increase the receptive field.
What’s more, a sequence of operations used in the bottleneck module (projection, convolution, projection) can be seen as decomposing one large convolutional layer into a series of smaller and simpler operations, that are its low-rank approximation. Such factorization allows for large speedups, and greatly reduces the number of parameters, making them less redundant. Additionally, it allows to make the functions they compute richer, thanks to the non-linear operations that are inserted between layers.

### Dilated convolutions 
As argued above, it is very important for the network to have a wide receptive field, so it can perform classification by taking a wider context into account. We wanted to avoid overly downsampling the feature maps, and decided to use dilated convolutions to improve our model. They replaced the main convolutional layers inside several bottleneck modules in the stages that operate on the smallest resolutions. These gave a significant accuracy boost, by raising IoU on Cityscapes by around 4 percentage points, with no additional cost. We obtained the best accuracy when we interleaved them with other bottleneck modules (both regular and asymmetric), instead of arranging them in sequence, as has been done in 30.

### Regularization 
Most pixel-wise segmentation datasets are relatively small (on order of 103 images), so such expressive models as neural networks quickly begin to overfit them. In initial experiments, we used L2 weight decay with little success. Then, inspired by 33, we have tried stochastic depth, which increased accuracy. However it became apparent that dropping whole branches (i.e. setting their output to 0) is in fact a special case of applying Spatial Dropout, where either all of the channels, or none of them are ignored, instead of selecting a random subset. We placed Spatial Dropout at the end of convolutional branches, right before the addition, and it turned out to work much better than stochastic depth.